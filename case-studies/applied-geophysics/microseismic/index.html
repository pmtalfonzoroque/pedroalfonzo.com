<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>Microseismic Monitoring ‚Äì Conceptual Workflow</title>

  <!-- FONT AWESOME ICONS -->
  <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.5.0/css/all.min.css">
  
  <!-- GLOBAL CSS -->
  <link rel="stylesheet" href="/assets/css/style.css">

  <!-- LOCAL CSS -->
  <link rel="stylesheet" href="style.css">
</head>

<body class="page page-background-sky">

  <!-- HEADER -->
  <div id="header"></div>

  <main class="content">

    <!-- PAGE TITLE -->
    <h1>Microseismic Monitoring</h1>
    <p class="intro">
      Conceptual workflow for event detection and interpretation in potash mining.
    </p>

    <!-- WHY IT MATTERS -->
    <section>
      <h2>Why Microseismic Monitoring Matters</h2>
      <p>
        Microseismic monitoring helps detect small-scale rock mass movements that are not visible 
        through traditional inspection. In high-conductivity environments like potash mines, 
        microseismic data supports ground control, safety, and operational decision-making.
      </p>
    </section>

    <!-- WORKFLOW -->
    <section>
      <h2>Conceptual Workflow</h2>
      <ol>
        <li><strong>Sensor Layout:</strong> Geophones or accelerometers installed in drifts or boreholes.</li>
        <li><strong>Noise Filtering:</strong> Removing machinery noise, ventilation noise, and background vibrations.</li>
        <li><strong>Event Detection:</strong> Identifying small seismic events within noisy data.</li>
        <li><strong>Event Location:</strong> Triangulating source position using arrival times.</li>
        <li><strong>Interpretation:</strong> Understanding rock mass behavior and potential instability.</li>
      </ol>
    </section>

    <!-- INTERACTIVE JS DEMO -->
    <section>
      <h2>Interactive Example ‚Äì Raw vs Filtered Signal</h2>
      <p>This simple synthetic example illustrates how filtering improves event visibility.</p>

      <div class="seismogram-container">
        <canvas id="waveformCanvas"></canvas>
      </div>

      <button id="toggleButton">Show Filtered Signal</button>
      <script src="script.js"></script>
    </section>

    <!-- PYTHON VIDEO -->
    <section>
      <h2>Python Demo ‚Äì Synthetic Microseismic Events</h2>
      <p>
        This short Python demonstration shows how synthetic microseismic events can be generated,
        filtered, and detected. It illustrates the first step of a real microseismic workflow:
        identifying event candidates within noisy data.
      </p>

      <h3>Level 1: Single-Trace Event Detection</h3>
      <p>
        The video below walks through the raw signal, the filtered signal, and the detection of
        local maxima (event candidates). This conceptual example is designed for educational
        purposes and mirrors the early stages of microseismic processing.
      </p>

      <div class="video-container">
        <iframe 
            src="https://www.youtube.com/embed/3s4gJdRp-q4?modestbranding=1&rel=0&showinfo=0"
            title="Microseismic Event Detection ‚Äì Level 1 Demo"
            frameborder="0"
            allow="accelerometer; autoplay; clipboard-write; encrypted-media; gyroscope; picture-in-picture"
            allowfullscreen>
        </iframe>
      </div>
    </section>

    <!-- LEVEL 2 -->
    <section>
      <h2>Level 2: Multi‚ÄëGeophone Synthetic Microseismic Example</h2>

      <p>
        Educational synthetic example using six geophones. A single microseismic event is recorded 
        across the array, with arrival times adjusted for visualization. The left panel shows the 
        filtered traces with detected peaks, and the right panel displays the corresponding 
        travel‚Äëtime trend across the geophones.
      </p>

      <img class="level2-image" src="/assets/images/microseismic_level2_multigeophone.JPG" 
          alt="Level 2 ‚Äì Multi-Geophone Synthetic Microseismic Event">

      <p class="caption">
        Figure: A single synthetic microseismic event recorded across six geophones. 
        Left: filtered traces with detected arrivals. Right: travel‚Äëtime trend used for 
        basic quality control and interpretation.
      </p>
    </section>

    <!-- LEVEL 3 -->
    <section>
      <h2>Level 3: From Arrival Times to Event Location</h2>
      <p>
        Building on the multi‚Äëgeophone example from Level 2, this section demonstrates how 
        arrival‚Äëtime differences can be used to estimate the location of a microseismic event. 
        The goal is to illustrate the core idea behind travel‚Äëtime inversion using a simple 
        synthetic example with six geophones.
      </p>
    </section>

    <section>
      <h3>3.1 Synthetic Setup</h3>
      <p>
        To remain consistent with Level 2, this example uses six geophones placed along a 
        horizontal drift. A synthetic microseismic event is defined below the array, and 
        theoretical travel times are computed using a constant velocity. Small perturbations 
        are added to mimic realistic picking uncertainty.
      </p>
    </section>

    <!-- COLLAPSIBLE: numeric/code details for setup -->
    <div class="info-box-collapsible">
      <button class="collapsible-btn" onclick="toggleSection('level3setup')">
        <span class="icon">üìê</span> Numeric details (show/hide)
        <span class="arrow">‚ñº</span>
      </button>

      <div id="level3setup" class="info-content">
        <pre><code>
    // Six geophones along a drift (meters)
    G = [
      {x: 0,  y: 0, z: 0},
      {x: 5,  y: 0, z: 0},
      {x: 10, y: 0, z: 0},
      {x: 15, y: 0, z: 0},
      {x: 20, y: 0, z: 0},
      {x: 25, y: 0, z: 0}
    ];

    // True event location
    E_true = {x: 12, y: 0, z: -18};

    // Velocity (m/s)
    v = 2500;

    // Travel-time function
    function travelTime(G, E, v) {
      let dx = G.x - E.x;
      let dy = G.y - E.y;
      let dz = G.z - E.z;
      let d  = Math.sqrt(dx*dx + dy*dy + dz*dz);
      return d / v;
    }
        </code></pre>
      </div>
    </div>

    <section>
      <h3>3.2 Arrival‚ÄëTime Inversion</h3>
      <p>
        Because the event origin time is unknown, the inversion uses arrival‚Äëtime differences 
        between geophones. With six sensors, the system is over‚Äëdetermined, which stabilizes 
        the solution and reduces sensitivity to noise. A simple 2D grid‚Äësearch inversion is 
        used for clarity.
      </p>
    </section>

    <!-- COLLAPSIBLE: numeric/code details for inversion -->
    <div class="info-box-collapsible">
      <button class="collapsible-btn" onclick="toggleSection('level3invert')">
        <span class="icon">üîß</span> Inversion details (show/hide)
        <span class="arrow">‚ñº</span>
      </button>

      <div id="level3invert" class="info-content">
        <pre><code>
    // Synthetic observed arrival times (with small noise)
    t_obs = G.map(g => travelTime(g, E_true, v) + (Math.random()*0.002 - 0.001));

    // Grid-search inversion
    function invertLocation(G, t_obs, v) {
      let best = {x: 0, z: 0, misfit: 1e9};

      for (let x = 0; x <= 25; x += 0.2) {
        for (let z = -40; z <= -5; z += 0.2) {
          let E = {x: x, y: 0, z: z};
          let t_calc = G.map(g => travelTime(g, E, v));

          let mis = 0;
          for (let i = 0; i < G.length - 1; i++) {
            let dt_obs  = t_obs[i+1] - t_obs[i];
            let dt_calc = t_calc[i+1] - t_calc[i];
            mis += Math.pow(dt_calc - dt_obs, 2);
          }

          if (mis < best.misfit) best = {x: x, z: z, misfit: mis};
        }
      }
      return best;
    }

    E_est = invertLocation(G, t_obs, v);
        </code></pre>
      </div>
    </div>

    <!-- REAL JAVASCRIPT (executed) -->
    <script>
    // Six geophones along a drift
    var G = [
      {x: 0,  y: 0, z: 0},
      {x: 5,  y: 0, z: 0},
      {x: 10, y: 0, z: 0},
      {x: 15, y: 0, z: 0},
      {x: 20, y: 0, z: 0},
      {x: 25, y: 0, z: 0}
    ];

    var E_true = {x: 12, y: 0, z: -18};
    var v = 2500;

    function travelTime(G, E, v) {
      let dx = G.x - E.x;
      let dy = G.y - E.y;
      let dz = G.z - E.z;
      let d  = Math.sqrt(dx*dx + dy*dy + dz*dz);
      return d / v;
    }

    var t_obs = G.map(g => travelTime(g, E_true, v) + (Math.random()*0.002 - 0.001));

    function invertLocation(G, t_obs, v) {
      let best = {x: 0, z: 0, misfit: 1e9};

      for (let x = 0; x <= 25; x += 0.2) {
        for (let z = -40; z <= -5; z += 0.2) {
          let E = {x: x, y: 0, z: z};
          let t_calc = G.map(g => travelTime(g, E, v));

          let mis = 0;
          for (let i = 0; i < G.length - 1; i++) {
            let dt_obs  = t_obs[i+1] - t_obs[i];
            let dt_calc = t_calc[i+1] - t_calc[i];
            mis += Math.pow(dt_calc - dt_obs, 2);
          }

          if (mis < best.misfit) best = {x: x, z: z, misfit: mis};
        }
      }
      return best;
    }

    var E_est = invertLocation(G, t_obs, v);
    </script>

    <section>
      <h3>3.3 Estimated Event Location</h3>
      <p>
        The cross‚Äësection below shows the six geophones, the true synthetic event, and the 
        estimated event obtained from the arrival‚Äëtime inversion. The small offset between 
        true and estimated location reflects realistic uncertainty due to noise, simplified 
        velocity assumptions, and grid resolution.
      </p>
    </section>

    <!-- INTERACTIVE PLOT CONTROLS -->
    <div style="text-align:center; margin-top:20px;">
      <label for="velSlider" style="color:white; font-weight:bold;">
        Velocity (m/s):
      </label>
      <input type="range" id="velSlider" min="1500" max="4500" value="2500" step="100" 
            oninput="updateVelocity(this.value)">
      <span id="velValue" style="color:white; margin-left:10px;">2500</span>
    </div>

    <!-- PLOT -->
    <div style="display:flex; justify-content:center; margin-top:20px;">
      <canvas id="level3Plot" width="700" height="400"></canvas>
    </div>

    <script>
    document.addEventListener("DOMContentLoaded", () => {

      const canvas = document.getElementById("level3Plot");
      const ctx3 = canvas.getContext("2d");

      const sx = 20, sz = 20; // equal scaling

      function drawPoint(ctx, x, y, color, label) {
        ctx.fillStyle = color;
        ctx.beginPath();
        ctx.arc(x, y, 6, 0, 2*Math.PI);
        ctx.fill();
        ctx.fillText(label, x + 10, y + 4);
      }

      function drawPlot() {
        // Dark background
        ctx3.fillStyle = "#1a1a1a";
        ctx3.fillRect(0, 0, canvas.width, canvas.height);

        ctx3.fillStyle = "white";
        ctx3.font = "16px Arial";
        ctx3.fillText("Cross‚ÄëSection View (x vs depth)", 240, 30);

        ctx3.font = "12px Arial";
        ctx3.fillText("x (m)", 650, 390);
        ctx3.fillText("depth (m)", 10, 390);

        // Draw geophones (surface)
        G.forEach((g, i) => {
          drawPoint(ctx3, g.x * sx, 80, "cyan", "G" + i);
        });

        // Draw true event (synthetic)
        drawPoint(ctx3, E_true.x * sx, 80 - E_true.z * sz, "lime", "True");

        // Draw estimated event
        drawPoint(ctx3, E_est.x * sx, 80 - E_est.z * sz, "red", "Estimated");
      }

      function updateVelocity(newVel) {
        document.getElementById("velValue").textContent = newVel;
        v = Number(newVel);

        // recompute arrival times
        t_obs = G.map(g => travelTime(g, E_true, v) + (Math.random()*0.002 - 0.001));

        // recompute inversion
        E_est = invertLocation(G, t_obs, v);

        drawPlot();
      }

      // expose function so slider can call it
      window.updateVelocity = updateVelocity;

      drawPlot();

    });
    </script>


    <p style="color:white; margin-top:10px;">
      <strong>Note:</strong> In real microseismic monitoring, the true event location is 
      never known. Only the <em>estimated</em> location is available, and its accuracy 
      depends heavily on the velocity model. Adjusting the velocity slider above shows 
      how incorrect velocities distort the estimated position ‚Äî which is why mines rely 
      on sonic logs, calibration blasts, and iterative velocity updates.
    </p>


  </main>

  <!-- FOOTER -->
  <div id="footer"></div>

  <script>
    async function loadComponent(id, file) {
      const container = document.getElementById(id);
      const response = await fetch(file);
      const html = await response.text();
      container.innerHTML = html;
    }
 
    loadComponent("header", "/components/header.html");
    loadComponent("footer", "/components/footer.html");
  </script>

  <script>
  function toggleSection(id) {
    const box = document.getElementById(id);
    if (!box) return;
    box.classList.toggle("open");
  }
  </script>


</body>
</html>
