<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>Microseismic Monitoring – Conceptual Workflow</title>

  <!-- FONT AWESOME ICONS -->
  <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.5.0/css/all.min.css">
  
  <!-- GLOBAL CSS -->
  <link rel="stylesheet" href="/assets/css/style.css">

  <!-- LOCAL CSS -->
  <link rel="stylesheet" href="style.css">
</head>

<body class="page page-background-sky">

  <!-- HEADER -->
  <div id="header"></div>

  <main class="content">

    <!-- PAGE TITLE -->
    <h1>Microseismic Monitoring</h1>
    <p class="intro">
      Conceptual workflow for event detection and interpretation in potash mining.
    </p>

    <!-- WHY IT MATTERS -->
    <section>
      <h2>Why Microseismic Monitoring Matters</h2>
      <p>
        Microseismic monitoring helps detect small-scale rock mass movements that are not visible 
        through traditional inspection. In high-conductivity environments like potash mines, 
        microseismic data supports ground control, safety, and operational decision-making.
      </p>
    </section>

    <!-- WORKFLOW -->
    <section>
      <h2>Conceptual Workflow</h2>
      <ol>
        <li><strong>Sensor Layout:</strong> Geophones or accelerometers installed in drifts or boreholes.</li>
        <li><strong>Noise Filtering:</strong> Removing machinery noise, ventilation noise, and background vibrations.</li>
        <li><strong>Event Detection:</strong> Identifying small seismic events within noisy data.</li>
        <li><strong>Event Location:</strong> Triangulating source position using arrival times.</li>
        <li><strong>Interpretation:</strong> Understanding rock mass behavior and potential instability.</li>
      </ol>
    </section>

    <!-- INTERACTIVE JS DEMO -->
    <section>
      <h2>Interactive Example – Raw vs Filtered Signal</h2>
      <p>This simple synthetic example illustrates how filtering improves event visibility.</p>

      <div class="seismogram-container">
        <canvas id="waveformCanvas"></canvas>
      </div>

      <button id="toggleButton">Show Filtered Signal</button>
      <script src="script.js"></script>
    </section>

    <!-- PYTHON VIDEO -->
    <section>
      <h2>Python Demo – Synthetic Microseismic Events</h2>
      <p>
        This short Python demonstration shows how synthetic microseismic events can be generated,
        filtered, and detected. It illustrates the first step of a real microseismic workflow:
        identifying event candidates within noisy data.
      </p>

      <h3>Level 1: Single-Trace Event Detection</h3>
      <p>
        The video below walks through the raw signal, the filtered signal, and the detection of
        local maxima (event candidates). This conceptual example is designed for educational
        purposes and mirrors the early stages of microseismic processing.
      </p>

      <div class="video-container">
        <iframe 
            src="https://www.youtube.com/embed/3s4gJdRp-q4?modestbranding=1&rel=0&showinfo=0"
            title="Microseismic Event Detection – Level 1 Demo"
            frameborder="0"
            allow="accelerometer; autoplay; clipboard-write; encrypted-media; gyroscope; picture-in-picture"
            allowfullscreen>
        </iframe>
      </div>
    </section>

    <!-- LEVEL 2 -->
    <section>
      <h2>Level 2: Multi‑Geophone Synthetic Microseismic Example</h2>

      <p>
        Educational synthetic example using six geophones. A single microseismic event is recorded 
        across the array, with arrival times adjusted for visualization. The left panel shows the 
        filtered traces with detected peaks, and the right panel displays the corresponding 
        travel‑time trend across the geophones.
      </p>

      <img class="level2-image" src="/assets/images/microseismic_level2_multigeophone.JPG" 
          alt="Level 2 – Multi-Geophone Synthetic Microseismic Event">

      <p class="caption">
        Figure: A single synthetic microseismic event recorded across six geophones. 
        Left: filtered traces with detected arrivals. Right: travel‑time trend used for 
        basic quality control and interpretation.
      </p>
    </section>

    <!-- LEVEL 3 -->
    <section>
      <h2>Level 3: From Arrival Times to Event Location</h2>
      <p>
        Building on the multi‑geophone example from Level 2, the next step is to use the 
        measured arrival times to estimate basic subsurface parameters. In real microseismic 
        processing, this typically involves a velocity model (from sonic logs, VSP, or 
        calibration shots) and an inversion that solves for the event’s origin time and 
        location. 
      </p>
      <p>
        For this educational example, I implement a simplified 1D approach: using the 
        travel‑time trend across the geophone array to estimate an effective velocity and 
        demonstrate how arrival‑time differences constrain the event position. The goal is 
        not to build a full microseismic locator, but to illustrate the core concepts behind 
        travel‑time inversion.
      </p>
    </section>
    <section>
      <h3>3.1 Synthetic Setup</h3>
      <p>
        To remain consistent with Level 2, this example uses six geophones placed along a 
        horizontal drift. A synthetic microseismic event is defined below the array, and 
        theoretical travel times are computed using a constant velocity of 2500 m/s. Small 
        perturbations are added to mimic realistic picking uncertainty.
      </p>

      <pre><code>
    // Six geophones along a drift (meters)
    G = [
      {x: 0,  y: 0, z: 0},
      {x: 5,  y: 0, z: 0},
      {x: 10, y: 0, z: 0},
      {x: 15, y: 0, z: 0},
      {x: 20, y: 0, z: 0},
      {x: 25, y: 0, z: 0}
    ];

    // True event location
    E_true = {x: 12, y: 0, z: -18};

    // Velocity (m/s)
    v = 2500;

    // Travel-time function
    function travelTime(G, E, v) {
      let dx = G.x - E.x;
      let dy = G.y - E.y;
      let dz = G.z - E.z;
      let d  = Math.sqrt(dx*dx + dy*dy + dz*dz);
      return d / v;
    }
      </code></pre>
    </section>
    <section>
      <h3>3.2 Arrival‑Time Inversion</h3>
      <p>
        Because the event origin time is unknown, the inversion uses arrival‑time 
        differences between geophones. With six sensors, the system is over‑determined, 
        which stabilizes the solution and reduces sensitivity to noise. A simple 2D 
        grid‑search inversion is used for clarity.
      </p>

      <pre><code>
    // Synthetic observed arrival times (with small noise)
    t_obs = G.map(g => travelTime(g, E_true, v) + (Math.random()*0.002 - 0.001));

    // Grid-search inversion
    function invertLocation(G, t_obs, v) {
      let best = {x: 0, z: 0, misfit: 1e9};

      for (let x = 0; x <= 25; x += 0.2) {
        for (let z = -40; z <= -5; z += 0.2) {
          let E = {x: x, y: 0, z: z};

          // Compute predicted times
          let t_calc = G.map(g => travelTime(g, E, v));

          // Misfit based on all arrival-time differences
          let mis = 0;
          for (let i = 0; i < G.length - 1; i++) {
            let dt_obs  = t_obs[i+1] - t_obs[i];
            let dt_calc = t_calc[i+1] - t_calc[i];
            mis += Math.pow(dt_calc - dt_obs, 2);
          }

          if (mis < best.misfit) {
            best = {x: x, z: z, misfit: mis};
          }
        }
      }
      return best;
    }

    let E_est = invertLocation(G, t_obs, v);
    console.log(E_est);
      </code></pre>
    </section>
    <section>
      <h3>3.3 Estimated Event Location</h3>
      <p>
        The plot below shows the six geophones, the true synthetic event, and the estimated 
        event obtained from the arrival‑time inversion. Even with a simple 1D velocity model, 
        the inversion recovers a location close to the true source.
      </p>

      <canvas id="level3Plot" width="700" height="350"></canvas>

      <script>
        const ctx3 = document.getElementById("level3Plot").getContext("2d");

        function drawPoint(ctx, x, y, color, label) {
          ctx.fillStyle = color;
          ctx.beginPath();
          ctx.arc(x, y, 5, 0, 2*Math.PI);
          ctx.fill();
          ctx.fillText(label, x + 8, y + 4);
        }

        const sx = 20, sz = 5;

        ctx3.font = "14px Arial";
        ctx3.fillText("Geophones (surface)", 10, 20);

        // Draw geophones
        G.forEach((g, i) => {
          drawPoint(ctx3, g.x * sx, 50, "blue", "G" + i);
        });

        // Draw true event
        drawPoint(ctx3, E_true.x * sx, 50 - E_true.z * sz, "green", "True");

        // Draw estimated event
        drawPoint(ctx3, E_est.x * sx, 50 - E_est.z * sz, "red", "Estimated");
      </script>

      <p>
        This simplified example demonstrates the core idea behind microseismic event 
        location: arrival‑time differences constrain the geometry of the source. In real 
        mining applications, 3D velocity models, calibration blasts, and additional sensors 
        further reduce uncertainty and improve location accuracy.
      </p>
    </section>





  </main>

  <!-- FOOTER -->
  <div id="footer"></div>

  <script>
    async function loadComponent(id, file) {
      const container = document.getElementById(id);
      const response = await fetch(file);
      const html = await response.text();
      container.innerHTML = html;
    }
 
    loadComponent("header", "/components/header.html");
    loadComponent("footer", "/components/footer.html");
  </script>

</body>
</html>
